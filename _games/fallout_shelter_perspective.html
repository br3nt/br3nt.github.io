---
layout: p5
title: Fallout Shelter Perspective
description: |
  <div>Recreation of the Fallout Shelter perspective effect with cabinet projection.</div>
  <div>Use F to zoom out, 1 to zoom to a room, G to toggle grid, mouse wheel to zoom, drag to pan, arrows to navigate.</div>
---

<script defer>

// Grid configuration
const GRID_WIDTH = 15;   // cells wide
const GRID_HEIGHT = 20;  // cells high
const CELL_WIDTH = 80;   // base width of each cell in pixels
const CELL_HEIGHT = 60;  // base height of each cell in pixels
const CELL_DEPTH = 30;   // depth for cabinet projection

// Global variables
let camera;
let grid = [];
let showGridLines = false;  // Toggle with 'G' key

// ============================================================================
// Camera Class - Handles smooth zoom/pan with snap-to-finish
// ============================================================================
class Camera {
  constructor() {
    // Current state
    this.x = 0;
    this.y = 0;
    this.zoom = 1;

    // Target state (for smooth animation)
    this.targetX = 0;
    this.targetY = 0;
    this.targetZoom = 1;

    // Animation configuration
    this.lerpFactor = 0.1;      // Base interpolation speed (0-1)
    this.snapThreshold = 0.01;  // Distance from target to snap
    this.snapFactor = 0.95;     // Aggressive lerp when close to target
  }

  // Update camera position with smooth interpolation
  update() {
    // Calculate distance to target
    const distX = abs(this.targetX - this.x);
    const distY = abs(this.targetY - this.y);
    const distZoom = abs(this.targetZoom - this.zoom);

    // Use aggressive snap if close to target
    const factor = (distX < this.snapThreshold &&
                    distY < this.snapThreshold &&
                    distZoom < this.snapThreshold)
                   ? this.snapFactor
                   : this.lerpFactor;

    // Smooth interpolation
    this.x = lerp(this.x, this.targetX, factor);
    this.y = lerp(this.y, this.targetY, factor);
    this.zoom = lerp(this.zoom, this.targetZoom, factor);

    // Snap to target if very close
    if (distX < 0.001) this.x = this.targetX;
    if (distY < 0.001) this.y = this.targetY;
    if (distZoom < 0.001) this.zoom = this.targetZoom;
  }

  // Apply camera transformation to canvas
  apply() {
    push();
    // Center viewport
    translate(width / 2, height / 2);
    // Apply zoom
    scale(this.zoom);
    // Apply camera position (negative to move world opposite direction)
    translate(-this.x, -this.y);
  }

  // Remove camera transformation
  unapply() {
    pop();
  }
}

// ============================================================================
// Room Class - Represents a single cell in the grid
// ============================================================================
class Room {
  constructor(x, y) {
    this.gridX = x;
    this.gridY = y;
    this.type = 'empty';
    // Assign a color based on position for visual distinction
    this.color = color(
      100 + (x * 10) % 100,
      150 + (y * 5) % 50,
      200 + ((x + y) * 8) % 55
    );
    // Furniture objects in this room
    this.objects = [];
  }

  addFurniture() {
    // TEMP: Add 3 test boxes using new grid coordinate system
    // Grid is 12x12x12 where (0,0,0) is bottom-left-front

    // Box 1: Origin (bottom-left-front) - 1x2x1 grid units
    this.objects.push({
      type: 'tv',
      gridX: 0,  // Left edge
      gridY: 0,  // Bottom (floor)
      gridZ: 0,  // Front
      gridWidth: 1,
      gridHeight: 2,
      gridDepth: 1
    });

    // Box 2: Bottom-right-front - 1x2x1 grid units
    this.objects.push({
      type: 'tv',
      gridX: 11,  // Right edge (12 - 1)
      gridY: 0,   // Bottom (floor)
      gridZ: 0,   // Front
      gridWidth: 1,
      gridHeight: 2,
      gridDepth: 1
    });

    // Box 3: Bottom-right-back - 1x2x1 grid units
    this.objects.push({
      type: 'tv',
      gridX: 11,  // Right edge
      gridY: 0,   // Bottom (floor)
      gridZ: 11,  // Back (12 - 1)
      gridWidth: 1,
      gridHeight: 2,
      gridDepth: 1
    });

    return; // Skip normal furniture generation for now

    // Add 1-3 random furniture items to the room
    const numItems = int(random(1, 4)); // 1-3 items
    const furnitureTypes = ['cupboard', 'tv', 'table', 'couch'];
    const usedTypes = [];

    // Generate x-positions based on number of items to avoid overlaps
    // These are OFFSETS from center (0.5), not absolute positions
    const xPositions = [];
    if (numItems === 1) {
      xPositions.push(0); // Center
    } else if (numItems === 2) {
      xPositions.push(-0.2, 0.2); // Left and right (smaller offset)
    } else { // 3 items
      xPositions.push(-0.25, 0, 0.25); // Left, center, right (smaller offset)
    }

    for (let i = 0; i < numItems; i++) {
      // Pick random furniture type not yet used
      let furnitureType;
      let attempts = 0;
      do {
        furnitureType = random(furnitureTypes);
        attempts++;
      } while (usedTypes.includes(furnitureType) && attempts < 10);

      if (attempts >= 10) break; // Safety check
      usedTypes.push(furnitureType);

      // Get x position for this item
      const x = xPositions[i];

      // Create furniture with proper coordinate system
      // Coordinate system: x,y,z are normalized 0-1
      // Origin at bottom-left: x(left->right), y(floor->ceiling), z(front->back)
      // To place on floor: y = height/2 (center of object)
      // Objects must stay within bounds: x in [width/2, 1-width/2], y in [height/2, 1-height/2]

      if (furnitureType === 'cupboard') {
        const width = 0.3;
        const height = 0.6;
        const xPos = constrain(0.5 + x, width/2, 1 - width/2);  // Keep within room
        this.objects.push({
          type: 'cupboard',
          z: 0.85,      // Depth: toward back wall
          x: xPos,
          y: height/2,  // Y position: center at half-height (sits on floor)
          width: width,
          height: height
        });
      } else if (furnitureType === 'tv') {
        const width = 0.15;
        const height = 0.3;
        const xPos = constrain(0.5 + x, width/2, 1 - width/2);
        this.objects.push({
          type: 'tv',
          z: 0.9,       // Against back wall
          x: xPos,
          y: 0.5,       // Wall-mounted at mid-height
          width: width,
          height: height
        });
      } else if (furnitureType === 'table') {
        const width = 0.4;
        const height = 0.3;
        const xPos = constrain(0.5 + x, width/2, 1 - width/2);
        this.objects.push({
          type: 'table',
          z: 0.5,       // Center of room
          x: xPos,
          y: height/2,  // Sits on floor
          width: width,
          height: height
        });
      } else if (furnitureType === 'couch') {
        const width = 0.3;
        const height = 0.35;
        const xPos = constrain(0.5 + x, width/2, 1 - width/2);
        this.objects.push({
          type: 'couch',
          z: 0.6,       // Slightly toward back
          x: xPos,
          y: height/2,  // Sits on floor
          width: width,
          height: height
        });
      }
    }
  }
}

// ============================================================================
// Coordinate Transformation Functions
// ============================================================================

// Convert grid coordinates to world coordinates
function gridToWorld(gridX, gridY) {
  const x = gridX * CELL_WIDTH + CELL_WIDTH / 2;
  const y = gridY * CELL_HEIGHT + CELL_HEIGHT / 2;
  return createVector(x, y);
}

// Convert world coordinates to grid coordinates
function worldToGrid(worldX, worldY) {
  const gridX = floor(worldX / CELL_WIDTH);
  const gridY = floor(worldY / CELL_HEIGHT);

  return {
    x: constrain(gridX, 0, GRID_WIDTH - 1),
    y: constrain(gridY, 0, GRID_HEIGHT - 1)
  };
}

// Convert screen/mouse coordinates to world coordinates
function screenToWorld(camera, screenX, screenY) {
  // Reverse the camera transformation
  // 1. Translate to origin
  const x1 = screenX - width / 2;
  const y1 = screenY - height / 2;

  // 2. Reverse scale
  const x2 = x1 / camera.zoom;
  const y2 = y1 / camera.zoom;

  // 3. Reverse camera translation
  const worldX = x2 + camera.x;
  const worldY = y2 + camera.y;

  return createVector(worldX, worldY);
}

// ============================================================================
// Zoom/Pan Control Functions
// ============================================================================

// Calculate zoom level to fit full grid on screen
function calculateFullGridView(camera) {
  // Total world dimensions in pixels
  const worldWidth = GRID_WIDTH * CELL_WIDTH;
  const worldHeight = GRID_HEIGHT * CELL_HEIGHT;

  // Add padding
  const padding = 40;

  // Calculate zoom to fit (choose smaller to fit both dimensions)
  const zoomX = (width - padding * 2) / worldWidth;
  const zoomY = (height - padding * 2) / worldHeight;
  camera.targetZoom = min(zoomX, zoomY);

  // Center on grid
  camera.targetX = worldWidth / 2;
  camera.targetY = worldHeight / 2;
}

// Calculate zoom to fill screen with single room
function zoomToRoom(camera, gridX, gridY) {
  // Calculate zoom to make left/right walls touch screen edges
  // (No padding - we want walls exactly at edges)
  camera.targetZoom = width / CELL_WIDTH;

  // Get room world position
  const roomWorldPos = gridToWorld(gridX, gridY);

  // Center camera horizontally on room
  camera.targetX = roomWorldPos.x;

  // Position camera vertically so floor is at bottom edge of screen
  // Floor is at roomY + CELL_HEIGHT/2 in world coords
  // We want: height = (roomY + CELL_HEIGHT/2 - camera.y) * zoom + height/2
  // Solving for camera.y: camera.y = roomY + CELL_HEIGHT/2 - height/(2*zoom)
  camera.targetY = roomWorldPos.y + CELL_HEIGHT/2 - height / (2 * camera.targetZoom);
}

// Pan to adjacent room (for keyboard navigation)
function panToAdjacentRoom(camera, dx, dy) {
  // Find current room from camera position
  const currentRoom = worldToGrid(camera.targetX, camera.targetY);

  // Move to adjacent room
  const newX = constrain(currentRoom.x + dx, 0, GRID_WIDTH - 1);
  const newY = constrain(currentRoom.y + dy, 0, GRID_HEIGHT - 1);

  zoomToRoom(camera, newX, newY);
}

// ============================================================================
// Drawing Functions
// ============================================================================

// Draw a single room (simple rectangle version for Phase 1)
function drawRoomSimple(room) {
  const worldPos = gridToWorld(room.gridX, room.gridY);

  push();
  translate(worldPos.x, worldPos.y);

  // Draw simple rectangle
  fill(room.color);
  stroke(50);
  strokeWeight(2);
  rectMode(CENTER);
  rect(0, 0, CELL_WIDTH - 4, CELL_HEIGHT - 4);

  pop();
}

// Perspective settings
const PERSPECTIVE_STRENGTH = 0.3;  // How much perspective distortion (0 = none, 1 = extreme)
const BACK_WALL_SCALE = 0.7;       // Back wall size relative to front (0.7 = 70% size)

// Room grid coordinate system
const ROOM_GRID_SIZE = 12;  // 12x12x12 grid per room

// Convert room grid coordinates to world drawing coordinates
// gridX, gridY, gridZ are integers 0-12
// Returns {x, y} in drawing coordinates (relative to room center)
function roomGridToWorld(gridX, gridY, gridZ, perspectiveShiftX, perspectiveShiftY) {
  const frameHalfWidth = 1.5;

  // Normalize grid coords to 0-1
  const nx = gridX / ROOM_GRID_SIZE;
  const ny = gridY / ROOM_GRID_SIZE;
  const nz = gridZ / ROOM_GRID_SIZE;

  // Front edges (z=0, at inner frame boundary)
  const frontLeft = -CELL_WIDTH/2 + frameHalfWidth;
  const frontRight = CELL_WIDTH/2 - frameHalfWidth;
  const frontFloor = CELL_HEIGHT/2 - frameHalfWidth;
  const frontCeiling = -CELL_HEIGHT/2 + frameHalfWidth;

  // Back edges (z=1, at back wall)
  const backWidth = CELL_WIDTH * BACK_WALL_SCALE;
  const backHeight = CELL_HEIGHT * BACK_WALL_SCALE;
  const backLeft = -backWidth/2 + perspectiveShiftX;
  const backRight = backWidth/2 + perspectiveShiftX;
  const backFloor = backHeight/2 + perspectiveShiftY;
  const backCeiling = -backHeight/2 + perspectiveShiftY;

  // Lerp edges from front to back based on depth
  const leftEdge = lerp(frontLeft, backLeft, nz);
  const rightEdge = lerp(frontRight, backRight, nz);
  const floorEdge = lerp(frontFloor, backFloor, nz);
  const ceilingEdge = lerp(frontCeiling, backCeiling, nz);

  // Position within the lerped bounds
  const worldX = lerp(leftEdge, rightEdge, nx);
  const worldY = lerp(floorEdge, ceilingEdge, ny);

  return {x: worldX, y: worldY};
}

// Draw a furniture object using grid coordinates
function drawFurnitureObject(obj, perspectiveShiftX, perspectiveShiftY) {
  // Object is defined by grid coordinates (integers 0-12)
  const {gridX, gridY, gridZ, gridWidth, gridHeight, gridDepth} = obj;

  // Get the 8 corners of the box in grid coordinates
  const corners = [
    // Front face (z = gridZ)
    {gx: gridX, gy: gridY, gz: gridZ},  // bottom-left-front
    {gx: gridX + gridWidth, gy: gridY, gz: gridZ},  // bottom-right-front
    {gx: gridX, gy: gridY + gridHeight, gz: gridZ},  // top-left-front
    {gx: gridX + gridWidth, gy: gridY + gridHeight, gz: gridZ},  // top-right-front
    // Back face (z = gridZ + gridDepth)
    {gx: gridX, gy: gridY, gz: gridZ + gridDepth},  // bottom-left-back
    {gx: gridX + gridWidth, gy: gridY, gz: gridZ + gridDepth},  // bottom-right-back
    {gx: gridX, gy: gridY + gridHeight, gz: gridZ + gridDepth},  // top-left-back
    {gx: gridX + gridWidth, gy: gridY + gridHeight, gz: gridZ + gridDepth}   // top-right-back
  ];

  // Convert all corners to world coordinates
  const worldCorners = corners.map(c => roomGridToWorld(c.gx, c.gy, c.gz, perspectiveShiftX, perspectiveShiftY));

  // Extract specific corners for drawing
  const frontBottomLeft = createVector(worldCorners[0].x, worldCorners[0].y);
  const frontBottomRight = createVector(worldCorners[1].x, worldCorners[1].y);
  const frontTopLeft = createVector(worldCorners[2].x, worldCorners[2].y);
  const frontTopRight = createVector(worldCorners[3].x, worldCorners[3].y);
  const backBottomLeft = createVector(worldCorners[4].x, worldCorners[4].y);
  const backBottomRight = createVector(worldCorners[5].x, worldCorners[5].y);
  const backTopLeft = createVector(worldCorners[6].x, worldCorners[6].y);
  const backTopRight = createVector(worldCorners[7].x, worldCorners[7].y);

  // Colors based on furniture type
  let baseColor;
  if (obj.type === 'cupboard') {
    baseColor = color(139, 90, 43); // Brown
  } else if (obj.type === 'tv') {
    baseColor = color(40, 40, 45); // Dark gray/black
  } else if (obj.type === 'table') {
    baseColor = color(160, 120, 80); // Light brown
  } else if (obj.type === 'couch') {
    baseColor = color(100, 80, 150); // Purple-ish
  } else {
    baseColor = color(150, 150, 150); // Default gray
  }

  const r = red(baseColor);
  const g = green(baseColor);
  const b = blue(baseColor);

  // Different shading for different faces (to show 3D depth)
  const backFaceColor = color(r * 0.6, g * 0.6, b * 0.6);
  const topFaceColor = color(r * 0.8, g * 0.8, b * 0.8);
  const leftFaceColor = color(r * 0.5, g * 0.5, b * 0.5);
  const rightFaceColor = color(r * 0.55, g * 0.55, b * 0.55);
  const frontFaceColor = baseColor;

  // Draw in back-to-front order
  noStroke();

  // 1. Back face
  fill(backFaceColor);
  quad(
    backTopLeft.x, backTopLeft.y,
    backTopRight.x, backTopRight.y,
    backBottomRight.x, backBottomRight.y,
    backBottomLeft.x, backBottomLeft.y
  );

  // 2. Top face
  fill(topFaceColor);
  quad(
    frontTopLeft.x, frontTopLeft.y,
    frontTopRight.x, frontTopRight.y,
    backTopRight.x, backTopRight.y,
    backTopLeft.x, backTopLeft.y
  );

  // 3. Left face
  fill(leftFaceColor);
  quad(
    frontTopLeft.x, frontTopLeft.y,
    backTopLeft.x, backTopLeft.y,
    backBottomLeft.x, backBottomLeft.y,
    frontBottomLeft.x, frontBottomLeft.y
  );

  // 4. Right face
  fill(rightFaceColor);
  quad(
    frontTopRight.x, frontTopRight.y,
    backTopRight.x, backTopRight.y,
    backBottomRight.x, backBottomRight.y,
    frontBottomRight.x, frontBottomRight.y
  );

  // 5. Front face
  fill(frontFaceColor);
  quad(
    frontTopLeft.x, frontTopLeft.y,
    frontTopRight.x, frontTopRight.y,
    frontBottomRight.x, frontBottomRight.y,
    frontBottomLeft.x, frontBottomLeft.y
  );

  // Draw edges for definition
  stroke(0, 100);
  strokeWeight(0.5);
  noFill();

  // Front edges
  line(frontTopLeft.x, frontTopLeft.y, frontTopRight.x, frontTopRight.y);
  line(frontTopRight.x, frontTopRight.y, frontBottomRight.x, frontBottomRight.y);
  line(frontBottomRight.x, frontBottomRight.y, frontBottomLeft.x, frontBottomLeft.y);
  line(frontBottomLeft.x, frontBottomLeft.y, frontTopLeft.x, frontTopLeft.y);

  // Depth edges
  line(frontTopLeft.x, frontTopLeft.y, backTopLeft.x, backTopLeft.y);
  line(frontTopRight.x, frontTopRight.y, backTopRight.x, backTopRight.y);
  line(frontBottomLeft.x, frontBottomLeft.y, backBottomLeft.x, backBottomLeft.y);
  line(frontBottomRight.x, frontBottomRight.y, backBottomRight.x, backBottomRight.y);
}

// Draw grid lines for the room coordinate system
function drawRoomGrid(perspectiveShiftX, perspectiveShiftY) {
  stroke(255, 255, 255, 30);  // White, very transparent
  strokeWeight(0.2);  // Ultra thin

  // Draw vertical lines (X direction) at different Z depths
  for (let z = 0; z <= ROOM_GRID_SIZE; z++) {
    for (let x = 0; x <= ROOM_GRID_SIZE; x++) {
      const bottom = roomGridToWorld(x, 0, z, perspectiveShiftX, perspectiveShiftY);
      const top = roomGridToWorld(x, ROOM_GRID_SIZE, z, perspectiveShiftX, perspectiveShiftY);
      line(bottom.x, bottom.y, top.x, top.y);
    }
  }

  // Draw horizontal lines (Y direction) at different Z depths
  for (let z = 0; z <= ROOM_GRID_SIZE; z++) {
    for (let y = 0; y <= ROOM_GRID_SIZE; y++) {
      const left = roomGridToWorld(0, y, z, perspectiveShiftX, perspectiveShiftY);
      const right = roomGridToWorld(ROOM_GRID_SIZE, y, z, perspectiveShiftX, perspectiveShiftY);
      line(left.x, left.y, right.x, right.y);
    }
  }

  // Draw depth lines (Z direction)
  for (let x = 0; x <= ROOM_GRID_SIZE; x++) {
    for (let y = 0; y <= ROOM_GRID_SIZE; y++) {
      const front = roomGridToWorld(x, y, 0, perspectiveShiftX, perspectiveShiftY);
      const back = roomGridToWorld(x, y, ROOM_GRID_SIZE, perspectiveShiftX, perspectiveShiftY);
      line(front.x, front.y, back.x, back.y);
    }
  }
}

// Draw a room with true perspective projection (vanishing point at screen center)
function drawRoom(room) {
  const worldPos = gridToWorld(room.gridX, room.gridY);

  push();
  translate(worldPos.x, worldPos.y);

  // Calculate this room's position on screen (after camera transform)
  // We need to know where this room appears relative to screen center
  // Screen center in world coordinates is camera position
  const offsetFromCameraX = worldPos.x - camera.x;
  const offsetFromCameraY = worldPos.y - camera.y;

  // Perspective effect: back wall shifts toward screen center
  // The farther from center, the more the back wall shifts toward it
  const perspectiveShiftX = -offsetFromCameraX * PERSPECTIVE_STRENGTH;
  const perspectiveShiftY = -offsetFromCameraY * PERSPECTIVE_STRENGTH;

  // Front face corners (full size - the opening we look through)
  // These are the CENTER of where the thick frame lines will be drawn
  const frontLeft = createVector(-CELL_WIDTH / 2, -CELL_HEIGHT / 2);
  const frontRight = createVector(CELL_WIDTH / 2, -CELL_HEIGHT / 2);
  const frontBottomLeft = createVector(-CELL_WIDTH / 2, CELL_HEIGHT / 2);
  const frontBottomRight = createVector(CELL_WIDTH / 2, CELL_HEIGHT / 2);

  // For wall geometry, meet at the EXACT inner corner of frame intersections
  // Thick frame strokeWeight is 3, so it extends 1.5px on each side from center
  const frameHalfWidth = 1.5;

  // Inner corners of the thick frame intersections (for wall quads - exact position)
  // Top-left intersection: inner corner is bottom-right of the intersection square
  const innerTopLeft = createVector(frontLeft.x + frameHalfWidth, frontLeft.y + frameHalfWidth);

  // Top-right intersection: inner corner is bottom-left of the intersection square
  const innerTopRight = createVector(frontRight.x - frameHalfWidth, frontRight.y + frameHalfWidth);

  // Bottom-left intersection: inner corner is top-right of the intersection square
  const innerBottomLeft = createVector(frontBottomLeft.x + frameHalfWidth, frontBottomLeft.y - frameHalfWidth);

  // Bottom-right intersection: inner corner is top-left of the intersection square
  const innerBottomRight = createVector(frontBottomRight.x - frameHalfWidth, frontBottomRight.y - frameHalfWidth);

  // Corner lines use the same exact inner corner points as wall quads
  // The thin strokeWeight (0.3) prevents them from sticking out
  const lineTopLeft = innerTopLeft;
  const lineTopRight = innerTopRight;
  const lineBottomLeft = innerBottomLeft;
  const lineBottomRight = innerBottomRight;

  // Also need outer corners for the quad geometry
  const outerTopLeft = createVector(frontLeft.x - frameHalfWidth, frontLeft.y - frameHalfWidth);
  const outerTopRight = createVector(frontRight.x + frameHalfWidth, frontRight.y - frameHalfWidth);
  const outerBottomLeft = createVector(frontBottomLeft.x - frameHalfWidth, frontBottomLeft.y + frameHalfWidth);
  const outerBottomRight = createVector(frontBottomRight.x + frameHalfWidth, frontBottomRight.y + frameHalfWidth);

  // Back wall corners (smaller and shifted toward screen center)
  const backWidth = CELL_WIDTH * BACK_WALL_SCALE;
  const backHeight = CELL_HEIGHT * BACK_WALL_SCALE;

  const backTopLeft = createVector(-backWidth / 2 + perspectiveShiftX, -backHeight / 2 + perspectiveShiftY);
  const backTopRight = createVector(backWidth / 2 + perspectiveShiftX, -backHeight / 2 + perspectiveShiftY);
  const backBottomLeft = createVector(-backWidth / 2 + perspectiveShiftX, backHeight / 2 + perspectiveShiftY);
  const backBottomRight = createVector(backWidth / 2 + perspectiveShiftX, backHeight / 2 + perspectiveShiftY);

  // Get base color
  const baseColor = room.color;
  const r = red(baseColor);
  const g = green(baseColor);
  const b = blue(baseColor);

  // Colors for different faces (to show depth)
  const backWallColor = color(r * 0.8, g * 0.8, b * 0.8);
  const leftWallColor = color(r * 0.65, g * 0.65, b * 0.65);
  const rightWallColor = color(r * 0.70, g * 0.70, b * 0.70);
  const ceilingColor = color(r * 0.75, g * 0.75, b * 0.75);
  const floorColor = color(r * 0.60, g * 0.60, b * 0.60);

  // Draw fills only (no stroke on quads - we'll draw corner lines separately)
  noStroke();

  // Draw in back-to-front order for proper occlusion

  // 1. Back wall (farthest into the room)
  fill(backWallColor);
  quad(
    backTopLeft.x, backTopLeft.y,
    backTopRight.x, backTopRight.y,
    backBottomRight.x, backBottomRight.y,
    backBottomLeft.x, backBottomLeft.y
  );

  // 2. Ceiling (top surface) - use INNER corners
  fill(ceilingColor);
  quad(
    innerTopLeft.x, innerTopLeft.y,
    innerTopRight.x, innerTopRight.y,
    backTopRight.x, backTopRight.y,
    backTopLeft.x, backTopLeft.y
  );

  // 3. Floor (bottom surface) - use INNER corners
  fill(floorColor);
  quad(
    innerBottomLeft.x, innerBottomLeft.y,
    innerBottomRight.x, innerBottomRight.y,
    backBottomRight.x, backBottomRight.y,
    backBottomLeft.x, backBottomLeft.y
  );

  // 4. Left wall (side) - use INNER corners
  fill(leftWallColor);
  quad(
    innerTopLeft.x, innerTopLeft.y,
    backTopLeft.x, backTopLeft.y,
    backBottomLeft.x, backBottomLeft.y,
    innerBottomLeft.x, innerBottomLeft.y
  );

  // 5. Right wall (side) - use INNER corners
  fill(rightWallColor);
  quad(
    innerTopRight.x, innerTopRight.y,
    backTopRight.x, backTopRight.y,
    backBottomRight.x, backBottomRight.y,
    innerBottomRight.x, innerBottomRight.y
  );

  // 5.5. Draw room grid lines (transparent) - toggle with 'G' key
  if (showGridLines) {
    drawRoomGrid(perspectiveShiftX, perspectiveShiftY);
  }

  // 5.6. Draw furniture objects in the room (back to front for proper z-ordering)
  const sortedObjects = [...room.objects].sort((a, b) => (b.gridZ || 0) - (a.gridZ || 0));
  for (const obj of sortedObjects) {
    drawFurnitureObject(obj, perspectiveShiftX, perspectiveShiftY);
  }

  // 6. Draw thin corner perspective lines (slightly inset from frame corners)
  stroke(40);
  strokeWeight(0.3);  // Very thin corner lines
  noFill();

  // Top-left corner line (from inset point to back wall)
  line(lineTopLeft.x, lineTopLeft.y, backTopLeft.x, backTopLeft.y);

  // Top-right corner line
  line(lineTopRight.x, lineTopRight.y, backTopRight.x, backTopRight.y);

  // Bottom-left corner line
  line(lineBottomLeft.x, lineBottomLeft.y, backBottomLeft.x, backBottomLeft.y);

  // Bottom-right corner line
  line(lineBottomRight.x, lineBottomRight.y, backBottomRight.x, backBottomRight.y);

  // Back wall edges (very thin lines, same as corners)
  stroke(40);
  strokeWeight(0.3);
  line(backTopLeft.x, backTopLeft.y, backTopRight.x, backTopRight.y); // top
  line(backTopRight.x, backTopRight.y, backBottomRight.x, backBottomRight.y); // right
  line(backBottomRight.x, backBottomRight.y, backBottomLeft.x, backBottomLeft.y); // bottom
  line(backBottomLeft.x, backBottomLeft.y, backTopLeft.x, backTopLeft.y); // left

  // 7. Draw thick front opening frame
  noFill();
  stroke(30);  // Dark frame color
  strokeWeight(3);

  // Top edge
  line(frontLeft.x, frontLeft.y, frontRight.x, frontRight.y);

  // Bottom edge
  line(frontBottomLeft.x, frontBottomLeft.y, frontBottomRight.x, frontBottomRight.y);

  // Left edge
  line(frontLeft.x, frontLeft.y, frontBottomLeft.x, frontBottomLeft.y);

  // Right edge
  line(frontRight.x, frontRight.y, frontBottomRight.x, frontBottomRight.y);

  pop();
}

// Draw UI overlay
function drawUI() {
  push();
  fill(255);
  noStroke();
  textSize(14);
  textAlign(LEFT, TOP);

  text(`Zoom: ${camera.zoom.toFixed(2)}`, 10, 10);
  text(`Position: (${camera.x.toFixed(0)}, ${camera.y.toFixed(0)})`, 10, 30);
  text(`FPS: ${frameRate().toFixed(0)}`, 10, 50);

  textSize(12);
  text(`Controls:`, 10, 80);
  text(`  F = Fit full grid`, 10, 100);
  text(`  1 = Zoom to room (7, 10)`, 10, 120);
  text(`  G = Toggle grid lines`, 10, 140);
  text(`  Arrow keys = Navigate rooms`, 10, 160);
  text(`  Mouse wheel = Zoom`, 10, 180);
  text(`  Mouse drag = Pan`, 10, 200);

  pop();
}

// ============================================================================
// p5.js Core Functions
// ============================================================================

function setup() {
  createCanvas(windowWidth, windowHeight);

  describe('Fallout Shelter perspective effect with cabinet projection.');

  // Initialize camera
  camera = new Camera();

  // Initialize grid
  for (let y = 0; y < GRID_HEIGHT; y++) {
    grid[y] = [];
    for (let x = 0; x < GRID_WIDTH; x++) {
      grid[y][x] = new Room(x, y);
      // Add furniture to some rooms (70% chance)
      if (random() < 0.7) {
        grid[y][x].addFurniture();
      }
    }
  }

  // Start with full grid view
  calculateFullGridView(camera);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  background(30, 30, 40);

  // Update camera
  camera.update();

  // Apply camera transformation
  camera.apply();

  // Draw all rooms sorted by distance from camera (painter's algorithm)
  // Rooms farther from camera = drawn first (background)
  // Rooms closer to camera = drawn last (foreground)

  // Flatten grid to array and calculate distance from camera for each room
  const roomsWithDistance = [];
  for (let y = 0; y < GRID_HEIGHT; y++) {
    for (let x = 0; x < GRID_WIDTH; x++) {
      const room = grid[y][x];
      const worldPos = gridToWorld(room.gridX, room.gridY);

      // Distance from camera (screen center in world space)
      const dx = worldPos.x - camera.x;
      const dy = worldPos.y - camera.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      roomsWithDistance.push({ room, distance });
    }
  }

  // Sort by distance - farthest first
  roomsWithDistance.sort((a, b) => b.distance - a.distance);

  // Draw in sorted order
  for (const item of roomsWithDistance) {
    drawRoom(item.room);
  }

  // Unapply camera transformation
  camera.unapply();

  // Draw UI (not affected by camera)
  drawUI();
}

// ============================================================================
// Input Handlers
// ============================================================================

// Mouse wheel for zoom
function mouseWheel(event) {
  // Calculate new zoom level
  const zoomDelta = event.delta > 0 ? 0.9 : 1.1;
  const newZoom = camera.targetZoom * zoomDelta;

  // Max zoom is when room fills screen width (walls touch edges)
  const minZoom = 0.1;
  const maxZoom = width / CELL_WIDTH;
  const snapThreshold = maxZoom * 0.95; // Snap when within 5% of max zoom

  // Check if we're at min/max zoom - if so, don't update anything
  if ((newZoom < minZoom && camera.targetZoom <= minZoom) ||
      (newZoom > maxZoom && camera.targetZoom >= maxZoom)) {
    // Already at limit - prevent any updates to avoid page scrolling
    return false;
  }

  // Apply zoom (constrained to max)
  camera.targetZoom = constrain(newZoom, minZoom, maxZoom);

  // Find the nearest room to camera center
  const nearestRoom = worldToGrid(camera.targetX, camera.targetY);
  const roomWorldPos = gridToWorld(nearestRoom.x, nearestRoom.y);

  // Calculate ideal snapped position (room centered, floor at bottom)
  const snappedX = roomWorldPos.x;
  const snappedY = roomWorldPos.y + CELL_HEIGHT/2 - height / (2 * camera.targetZoom);

  // Check if we should snap to max zoom
  if (camera.targetZoom >= snapThreshold && event.delta < 0) {
    // Full snap to max zoom and ideal position
    camera.targetZoom = maxZoom;
    camera.targetX = snappedX;
    camera.targetY = snappedY;
  } else {
    // Get world position under mouse before zoom
    const worldPosBefore = screenToWorld(camera, mouseX, mouseY);

    // Calculate how close we are to max zoom (0 to 1)
    const zoomProgress = constrain(camera.targetZoom / maxZoom, 0, 1);

    // Blend between "zoom toward mouse" and "snap to room center"
    // As we approach max zoom, gradually shift toward snapped position
    const blendFactor = pow(zoomProgress, 3); // Cubic easing for smooth transition

    camera.targetX = lerp(worldPosBefore.x, snappedX, blendFactor);
    camera.targetY = lerp(worldPosBefore.y, snappedY, blendFactor);
  }

  return false; // Prevent default scrolling
}

// Mouse drag for pan
let isDragging = false;
let dragStart = null;

function mousePressed() {
  isDragging = true;
  dragStart = createVector(mouseX, mouseY);
}

function mouseDragged() {
  if (isDragging && dragStart) {
    const dx = mouseX - dragStart.x;
    const dy = mouseY - dragStart.y;

    // Move camera (inverse of drag direction, scaled by zoom)
    camera.targetX -= dx / camera.zoom;
    camera.targetY -= dy / camera.zoom;

    // Update current position immediately for smooth dragging
    camera.x = camera.targetX;
    camera.y = camera.targetY;

    dragStart = createVector(mouseX, mouseY);
  }
}

function mouseReleased() {
  isDragging = false;
  dragStart = null;
}

// Keyboard controls
function keyPressed() {
  if (key === 'f' || key === 'F') {
    // Fit full grid
    calculateFullGridView(camera);
  } else if (key === '1') {
    // Zoom to specific room (example: room at 7, 10)
    zoomToRoom(camera, 7, 10);
  } else if (key === 'g' || key === 'G') {
    // Toggle grid lines
    showGridLines = !showGridLines;
  } else if (keyCode === LEFT_ARROW) {
    panToAdjacentRoom(camera, -1, 0);
  } else if (keyCode === RIGHT_ARROW) {
    panToAdjacentRoom(camera, 1, 0);
  } else if (keyCode === UP_ARROW) {
    panToAdjacentRoom(camera, 0, -1);
  } else if (keyCode === DOWN_ARROW) {
    panToAdjacentRoom(camera, 0, 1);
  }
}

</script>
