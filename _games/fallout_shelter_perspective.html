---
layout: p5
title: Fallout Shelter Perspective
description: |
  <div>Recreation of the Fallout Shelter perspective effect with cabinet projection.</div>
  <div>Use F to zoom out, 1 to zoom to a room, mouse wheel to zoom, drag to pan, arrows to navigate.</div>
---

<script defer>

// Grid configuration
const GRID_WIDTH = 15;   // cells wide
const GRID_HEIGHT = 20;  // cells high
const CELL_WIDTH = 80;   // base width of each cell in pixels
const CELL_HEIGHT = 60;  // base height of each cell in pixels
const CELL_DEPTH = 30;   // depth for cabinet projection

// Global variables
let camera;
let grid = [];

// ============================================================================
// Camera Class - Handles smooth zoom/pan with snap-to-finish
// ============================================================================
class Camera {
  constructor() {
    // Current state
    this.x = 0;
    this.y = 0;
    this.zoom = 1;

    // Target state (for smooth animation)
    this.targetX = 0;
    this.targetY = 0;
    this.targetZoom = 1;

    // Animation configuration
    this.lerpFactor = 0.1;      // Base interpolation speed (0-1)
    this.snapThreshold = 0.01;  // Distance from target to snap
    this.snapFactor = 0.95;     // Aggressive lerp when close to target
  }

  // Update camera position with smooth interpolation
  update() {
    // Calculate distance to target
    const distX = abs(this.targetX - this.x);
    const distY = abs(this.targetY - this.y);
    const distZoom = abs(this.targetZoom - this.zoom);

    // Use aggressive snap if close to target
    const factor = (distX < this.snapThreshold &&
                    distY < this.snapThreshold &&
                    distZoom < this.snapThreshold)
                   ? this.snapFactor
                   : this.lerpFactor;

    // Smooth interpolation
    this.x = lerp(this.x, this.targetX, factor);
    this.y = lerp(this.y, this.targetY, factor);
    this.zoom = lerp(this.zoom, this.targetZoom, factor);

    // Snap to target if very close
    if (distX < 0.001) this.x = this.targetX;
    if (distY < 0.001) this.y = this.targetY;
    if (distZoom < 0.001) this.zoom = this.targetZoom;
  }

  // Apply camera transformation to canvas
  apply() {
    push();
    // Center viewport
    translate(width / 2, height / 2);
    // Apply zoom
    scale(this.zoom);
    // Apply camera position (negative to move world opposite direction)
    translate(-this.x, -this.y);
  }

  // Remove camera transformation
  unapply() {
    pop();
  }
}

// ============================================================================
// Room Class - Represents a single cell in the grid
// ============================================================================
class Room {
  constructor(x, y) {
    this.gridX = x;
    this.gridY = y;
    this.type = 'empty';
    // Assign a color based on position for visual distinction
    this.color = color(
      100 + (x * 10) % 100,
      150 + (y * 5) % 50,
      200 + ((x + y) * 8) % 55
    );
  }
}

// ============================================================================
// Coordinate Transformation Functions
// ============================================================================

// Convert grid coordinates to world coordinates
function gridToWorld(gridX, gridY) {
  const x = gridX * CELL_WIDTH + CELL_WIDTH / 2;
  const y = gridY * CELL_HEIGHT + CELL_HEIGHT / 2;
  return createVector(x, y);
}

// Convert world coordinates to grid coordinates
function worldToGrid(worldX, worldY) {
  const gridX = floor(worldX / CELL_WIDTH);
  const gridY = floor(worldY / CELL_HEIGHT);

  return {
    x: constrain(gridX, 0, GRID_WIDTH - 1),
    y: constrain(gridY, 0, GRID_HEIGHT - 1)
  };
}

// Convert screen/mouse coordinates to world coordinates
function screenToWorld(camera, screenX, screenY) {
  // Reverse the camera transformation
  // 1. Translate to origin
  const x1 = screenX - width / 2;
  const y1 = screenY - height / 2;

  // 2. Reverse scale
  const x2 = x1 / camera.zoom;
  const y2 = y1 / camera.zoom;

  // 3. Reverse camera translation
  const worldX = x2 + camera.x;
  const worldY = y2 + camera.y;

  return createVector(worldX, worldY);
}

// ============================================================================
// Zoom/Pan Control Functions
// ============================================================================

// Calculate zoom level to fit full grid on screen
function calculateFullGridView(camera) {
  // Total world dimensions in pixels
  const worldWidth = GRID_WIDTH * CELL_WIDTH;
  const worldHeight = GRID_HEIGHT * CELL_HEIGHT;

  // Add padding
  const padding = 40;

  // Calculate zoom to fit (choose smaller to fit both dimensions)
  const zoomX = (width - padding * 2) / worldWidth;
  const zoomY = (height - padding * 2) / worldHeight;
  camera.targetZoom = min(zoomX, zoomY);

  // Center on grid
  camera.targetX = worldWidth / 2;
  camera.targetY = worldHeight / 2;
}

// Calculate zoom to fill screen with single room
function zoomToRoom(camera, gridX, gridY) {
  // Calculate zoom to make left/right walls touch screen edges
  // (No padding - we want walls exactly at edges)
  camera.targetZoom = width / CELL_WIDTH;

  // Get room world position
  const roomWorldPos = gridToWorld(gridX, gridY);

  // Center camera horizontally on room
  camera.targetX = roomWorldPos.x;

  // Position camera vertically so floor is at bottom edge of screen
  // Floor is at roomY + CELL_HEIGHT/2 in world coords
  // We want: height = (roomY + CELL_HEIGHT/2 - camera.y) * zoom + height/2
  // Solving for camera.y: camera.y = roomY + CELL_HEIGHT/2 - height/(2*zoom)
  camera.targetY = roomWorldPos.y + CELL_HEIGHT/2 - height / (2 * camera.targetZoom);
}

// Pan to adjacent room (for keyboard navigation)
function panToAdjacentRoom(camera, dx, dy) {
  // Find current room from camera position
  const currentRoom = worldToGrid(camera.targetX, camera.targetY);

  // Move to adjacent room
  const newX = constrain(currentRoom.x + dx, 0, GRID_WIDTH - 1);
  const newY = constrain(currentRoom.y + dy, 0, GRID_HEIGHT - 1);

  zoomToRoom(camera, newX, newY);
}

// ============================================================================
// Drawing Functions
// ============================================================================

// Draw a single room (simple rectangle version for Phase 1)
function drawRoomSimple(room) {
  const worldPos = gridToWorld(room.gridX, room.gridY);

  push();
  translate(worldPos.x, worldPos.y);

  // Draw simple rectangle
  fill(room.color);
  stroke(50);
  strokeWeight(2);
  rectMode(CENTER);
  rect(0, 0, CELL_WIDTH - 4, CELL_HEIGHT - 4);

  pop();
}

// Perspective settings
const PERSPECTIVE_STRENGTH = 0.3;  // How much perspective distortion (0 = none, 1 = extreme)
const BACK_WALL_SCALE = 0.7;       // Back wall size relative to front (0.7 = 70% size)

// Draw a room with true perspective projection (vanishing point at screen center)
function drawRoom(room) {
  const worldPos = gridToWorld(room.gridX, room.gridY);

  push();
  translate(worldPos.x, worldPos.y);

  // Calculate this room's position on screen (after camera transform)
  // We need to know where this room appears relative to screen center
  // Screen center in world coordinates is camera position
  const offsetFromCameraX = worldPos.x - camera.x;
  const offsetFromCameraY = worldPos.y - camera.y;

  // Perspective effect: back wall shifts toward screen center
  // The farther from center, the more the back wall shifts toward it
  const perspectiveShiftX = -offsetFromCameraX * PERSPECTIVE_STRENGTH;
  const perspectiveShiftY = -offsetFromCameraY * PERSPECTIVE_STRENGTH;

  // Front face corners (full size - the opening we look through)
  // These are the CENTER of where the thick frame lines will be drawn
  const frontLeft = createVector(-CELL_WIDTH / 2, -CELL_HEIGHT / 2);
  const frontRight = createVector(CELL_WIDTH / 2, -CELL_HEIGHT / 2);
  const frontBottomLeft = createVector(-CELL_WIDTH / 2, CELL_HEIGHT / 2);
  const frontBottomRight = createVector(CELL_WIDTH / 2, CELL_HEIGHT / 2);

  // For wall geometry, meet at the EXACT inner corner of frame intersections
  // Thick frame strokeWeight is 3, so it extends 1.5px on each side from center
  const frameHalfWidth = 1.5;

  // Inner corners of the thick frame intersections (for wall quads - exact position)
  // Top-left intersection: inner corner is bottom-right of the intersection square
  const innerTopLeft = createVector(frontLeft.x + frameHalfWidth, frontLeft.y + frameHalfWidth);

  // Top-right intersection: inner corner is bottom-left of the intersection square
  const innerTopRight = createVector(frontRight.x - frameHalfWidth, frontRight.y + frameHalfWidth);

  // Bottom-left intersection: inner corner is top-right of the intersection square
  const innerBottomLeft = createVector(frontBottomLeft.x + frameHalfWidth, frontBottomLeft.y - frameHalfWidth);

  // Bottom-right intersection: inner corner is top-left of the intersection square
  const innerBottomRight = createVector(frontBottomRight.x - frameHalfWidth, frontBottomRight.y - frameHalfWidth);

  // Corner lines use the same exact inner corner points as wall quads
  // The thin strokeWeight (0.3) prevents them from sticking out
  const lineTopLeft = innerTopLeft;
  const lineTopRight = innerTopRight;
  const lineBottomLeft = innerBottomLeft;
  const lineBottomRight = innerBottomRight;

  // Also need outer corners for the quad geometry
  const outerTopLeft = createVector(frontLeft.x - frameHalfWidth, frontLeft.y - frameHalfWidth);
  const outerTopRight = createVector(frontRight.x + frameHalfWidth, frontRight.y - frameHalfWidth);
  const outerBottomLeft = createVector(frontBottomLeft.x - frameHalfWidth, frontBottomLeft.y + frameHalfWidth);
  const outerBottomRight = createVector(frontBottomRight.x + frameHalfWidth, frontBottomRight.y + frameHalfWidth);

  // Back wall corners (smaller and shifted toward screen center)
  const backWidth = CELL_WIDTH * BACK_WALL_SCALE;
  const backHeight = CELL_HEIGHT * BACK_WALL_SCALE;

  const backTopLeft = createVector(-backWidth / 2 + perspectiveShiftX, -backHeight / 2 + perspectiveShiftY);
  const backTopRight = createVector(backWidth / 2 + perspectiveShiftX, -backHeight / 2 + perspectiveShiftY);
  const backBottomLeft = createVector(-backWidth / 2 + perspectiveShiftX, backHeight / 2 + perspectiveShiftY);
  const backBottomRight = createVector(backWidth / 2 + perspectiveShiftX, backHeight / 2 + perspectiveShiftY);

  // Get base color
  const baseColor = room.color;
  const r = red(baseColor);
  const g = green(baseColor);
  const b = blue(baseColor);

  // Colors for different faces (to show depth)
  const backWallColor = color(r * 0.8, g * 0.8, b * 0.8);
  const leftWallColor = color(r * 0.65, g * 0.65, b * 0.65);
  const rightWallColor = color(r * 0.70, g * 0.70, b * 0.70);
  const ceilingColor = color(r * 0.75, g * 0.75, b * 0.75);
  const floorColor = color(r * 0.60, g * 0.60, b * 0.60);

  // Draw fills only (no stroke on quads - we'll draw corner lines separately)
  noStroke();

  // Draw in back-to-front order for proper occlusion

  // 1. Back wall (farthest into the room)
  fill(backWallColor);
  quad(
    backTopLeft.x, backTopLeft.y,
    backTopRight.x, backTopRight.y,
    backBottomRight.x, backBottomRight.y,
    backBottomLeft.x, backBottomLeft.y
  );

  // 2. Ceiling (top surface) - use INNER corners
  fill(ceilingColor);
  quad(
    innerTopLeft.x, innerTopLeft.y,
    innerTopRight.x, innerTopRight.y,
    backTopRight.x, backTopRight.y,
    backTopLeft.x, backTopLeft.y
  );

  // 3. Floor (bottom surface) - use INNER corners
  fill(floorColor);
  quad(
    innerBottomLeft.x, innerBottomLeft.y,
    innerBottomRight.x, innerBottomRight.y,
    backBottomRight.x, backBottomRight.y,
    backBottomLeft.x, backBottomLeft.y
  );

  // 4. Left wall (side) - use INNER corners
  fill(leftWallColor);
  quad(
    innerTopLeft.x, innerTopLeft.y,
    backTopLeft.x, backTopLeft.y,
    backBottomLeft.x, backBottomLeft.y,
    innerBottomLeft.x, innerBottomLeft.y
  );

  // 5. Right wall (side) - use INNER corners
  fill(rightWallColor);
  quad(
    innerTopRight.x, innerTopRight.y,
    backTopRight.x, backTopRight.y,
    backBottomRight.x, backBottomRight.y,
    innerBottomRight.x, innerBottomRight.y
  );

  // 6. Draw thin corner perspective lines (slightly inset from frame corners)
  stroke(40);
  strokeWeight(0.3);  // Very thin corner lines
  noFill();

  // Top-left corner line (from inset point to back wall)
  line(lineTopLeft.x, lineTopLeft.y, backTopLeft.x, backTopLeft.y);

  // Top-right corner line
  line(lineTopRight.x, lineTopRight.y, backTopRight.x, backTopRight.y);

  // Bottom-left corner line
  line(lineBottomLeft.x, lineBottomLeft.y, backBottomLeft.x, backBottomLeft.y);

  // Bottom-right corner line
  line(lineBottomRight.x, lineBottomRight.y, backBottomRight.x, backBottomRight.y);

  // Back wall edges (very thin lines, same as corners)
  stroke(40);
  strokeWeight(0.3);
  line(backTopLeft.x, backTopLeft.y, backTopRight.x, backTopRight.y); // top
  line(backTopRight.x, backTopRight.y, backBottomRight.x, backBottomRight.y); // right
  line(backBottomRight.x, backBottomRight.y, backBottomLeft.x, backBottomLeft.y); // bottom
  line(backBottomLeft.x, backBottomLeft.y, backTopLeft.x, backTopLeft.y); // left

  // 7. Draw thick front opening frame
  noFill();
  stroke(30);  // Dark frame color
  strokeWeight(3);

  // Top edge
  line(frontLeft.x, frontLeft.y, frontRight.x, frontRight.y);

  // Bottom edge
  line(frontBottomLeft.x, frontBottomLeft.y, frontBottomRight.x, frontBottomRight.y);

  // Left edge
  line(frontLeft.x, frontLeft.y, frontBottomLeft.x, frontBottomLeft.y);

  // Right edge
  line(frontRight.x, frontRight.y, frontBottomRight.x, frontBottomRight.y);

  pop();
}

// Draw UI overlay
function drawUI() {
  push();
  fill(255);
  noStroke();
  textSize(14);
  textAlign(LEFT, TOP);

  text(`Zoom: ${camera.zoom.toFixed(2)}`, 10, 10);
  text(`Position: (${camera.x.toFixed(0)}, ${camera.y.toFixed(0)})`, 10, 30);
  text(`FPS: ${frameRate().toFixed(0)}`, 10, 50);

  textSize(12);
  text(`Controls:`, 10, 80);
  text(`  F = Fit full grid`, 10, 100);
  text(`  1 = Zoom to room (7, 10)`, 10, 120);
  text(`  Arrow keys = Navigate rooms`, 10, 140);
  text(`  Mouse wheel = Zoom`, 10, 160);
  text(`  Mouse drag = Pan`, 10, 180);

  pop();
}

// ============================================================================
// p5.js Core Functions
// ============================================================================

function setup() {
  createCanvas(windowWidth, windowHeight);

  describe('Fallout Shelter perspective effect with cabinet projection.');

  // Initialize camera
  camera = new Camera();

  // Initialize grid
  for (let y = 0; y < GRID_HEIGHT; y++) {
    grid[y] = [];
    for (let x = 0; x < GRID_WIDTH; x++) {
      grid[y][x] = new Room(x, y);
    }
  }

  // Start with full grid view
  calculateFullGridView(camera);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  background(30, 30, 40);

  // Update camera
  camera.update();

  // Apply camera transformation
  camera.apply();

  // Draw all rooms sorted by distance from camera (painter's algorithm)
  // Rooms farther from camera = drawn first (background)
  // Rooms closer to camera = drawn last (foreground)

  // Flatten grid to array and calculate distance from camera for each room
  const roomsWithDistance = [];
  for (let y = 0; y < GRID_HEIGHT; y++) {
    for (let x = 0; x < GRID_WIDTH; x++) {
      const room = grid[y][x];
      const worldPos = gridToWorld(room.gridX, room.gridY);

      // Distance from camera (screen center in world space)
      const dx = worldPos.x - camera.x;
      const dy = worldPos.y - camera.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      roomsWithDistance.push({ room, distance });
    }
  }

  // Sort by distance - farthest first
  roomsWithDistance.sort((a, b) => b.distance - a.distance);

  // Draw in sorted order
  for (const item of roomsWithDistance) {
    drawRoom(item.room);
  }

  // Unapply camera transformation
  camera.unapply();

  // Draw UI (not affected by camera)
  drawUI();
}

// ============================================================================
// Input Handlers
// ============================================================================

// Mouse wheel for zoom
function mouseWheel(event) {
  // Calculate new zoom level
  const zoomDelta = event.delta > 0 ? 0.9 : 1.1;
  const newZoom = camera.targetZoom * zoomDelta;

  // Max zoom is when room fills screen width (walls touch edges)
  const minZoom = 0.1;
  const maxZoom = width / CELL_WIDTH;
  const snapThreshold = maxZoom * 0.95; // Snap when within 5% of max zoom

  // Check if we're at min/max zoom - if so, don't update anything
  if ((newZoom < minZoom && camera.targetZoom <= minZoom) ||
      (newZoom > maxZoom && camera.targetZoom >= maxZoom)) {
    // Already at limit - prevent any updates to avoid page scrolling
    return false;
  }

  // Apply zoom (constrained to max)
  camera.targetZoom = constrain(newZoom, minZoom, maxZoom);

  // Find the nearest room to camera center
  const nearestRoom = worldToGrid(camera.targetX, camera.targetY);
  const roomWorldPos = gridToWorld(nearestRoom.x, nearestRoom.y);

  // Calculate ideal snapped position (room centered, floor at bottom)
  const snappedX = roomWorldPos.x;
  const snappedY = roomWorldPos.y + CELL_HEIGHT/2 - height / (2 * camera.targetZoom);

  // Check if we should snap to max zoom
  if (camera.targetZoom >= snapThreshold && event.delta < 0) {
    // Full snap to max zoom and ideal position
    camera.targetZoom = maxZoom;
    camera.targetX = snappedX;
    camera.targetY = snappedY;
  } else {
    // Get world position under mouse before zoom
    const worldPosBefore = screenToWorld(camera, mouseX, mouseY);

    // Calculate how close we are to max zoom (0 to 1)
    const zoomProgress = constrain(camera.targetZoom / maxZoom, 0, 1);

    // Blend between "zoom toward mouse" and "snap to room center"
    // As we approach max zoom, gradually shift toward snapped position
    const blendFactor = pow(zoomProgress, 3); // Cubic easing for smooth transition

    camera.targetX = lerp(worldPosBefore.x, snappedX, blendFactor);
    camera.targetY = lerp(worldPosBefore.y, snappedY, blendFactor);
  }

  return false; // Prevent default scrolling
}

// Mouse drag for pan
let isDragging = false;
let dragStart = null;

function mousePressed() {
  isDragging = true;
  dragStart = createVector(mouseX, mouseY);
}

function mouseDragged() {
  if (isDragging && dragStart) {
    const dx = mouseX - dragStart.x;
    const dy = mouseY - dragStart.y;

    // Move camera (inverse of drag direction, scaled by zoom)
    camera.targetX -= dx / camera.zoom;
    camera.targetY -= dy / camera.zoom;

    // Update current position immediately for smooth dragging
    camera.x = camera.targetX;
    camera.y = camera.targetY;

    dragStart = createVector(mouseX, mouseY);
  }
}

function mouseReleased() {
  isDragging = false;
  dragStart = null;
}

// Keyboard controls
function keyPressed() {
  if (key === 'f' || key === 'F') {
    // Fit full grid
    calculateFullGridView(camera);
  } else if (key === '1') {
    // Zoom to specific room (example: room at 7, 10)
    zoomToRoom(camera, 7, 10);
  } else if (keyCode === LEFT_ARROW) {
    panToAdjacentRoom(camera, -1, 0);
  } else if (keyCode === RIGHT_ARROW) {
    panToAdjacentRoom(camera, 1, 0);
  } else if (keyCode === UP_ARROW) {
    panToAdjacentRoom(camera, 0, -1);
  } else if (keyCode === DOWN_ARROW) {
    panToAdjacentRoom(camera, 0, 1);
  }
}

</script>
