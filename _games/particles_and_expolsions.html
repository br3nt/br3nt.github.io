---
layout: p5
title: Particles and explosions
description: |
  <div>experimenting with different particle and explosion effects.</div>
---


<template>
  TODO:
  * [ ] efffects from lazers shooting things
  * [ ] effects from things being shot
  * [ ] lasers
  * [ ] Neon lines
  * [ ] propelled rockets
  * [ ] electic bolts
  * [ ] ships exploding and flying apart
  * [ ] ships accelarating
  * [ ] the two pronged projectile that kind of ladders along, _-  -> -_  -> _- 
  * [ ] shields
  * [ ] shields getting hit
</template>

<script defer>

let gravity
let emitter
let clickExplosions = []

function setup() {
  createCanvas(windowWidth, windowHeight)

  describe('Particles and explosions.')

  gravity = createVector(0, 0.5);
  emitter = new Emitter(width / 2, 50)
  emitter.addParticle(new Particle(width / 2, 50))

}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight)
}

function draw() {

  drawNeonSquare()

  emitter.update()
  emitter.draw()
  emitter.applyForce(gravity)

  // Update and draw click explosions
  clickExplosions.forEach(explosion => {
    explosion.update()
    explosion.draw()
  })

  // Remove dead explosions
  clickExplosions = clickExplosions.filter(e => !e.isDead)

  // Display FPS
  push()
  fill(255)
  noStroke()
  textSize(16)
  textAlign(LEFT, TOP)
  text(`FPS: ${frameRate().toFixed(0)} | Particles: ${clickExplosions.reduce((sum, e) => sum + e.particles.length, 0)}`, 10, 10)
  pop()
}

function mousePressed() {
  // Create explosion at click position
  // Parameters: (position, lifetime, maxVelocity, particleCount, maxOffset)
  // - lifetime: how long particles live (larger = spread further)
  // - maxVelocity: initial speed (larger = spread faster/further)
  // - particleCount: number of particles (null = random 15-30)
  // - maxOffset: initial spread radius from click point

  // Examples:
  // Small, fast burst:
  // clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 30, 20, null, 0))

  // Large, slow expansion:
  // clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 120, 8, null, 0))

  // Tight cluster with offset spread:
  // clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 60, 10, null, 20))

  // Large burst with initial spread:
  // clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 80, 15, 40, 30))

  // Default medium effect with slight offset:
  clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 60, 15, null, 10))
}

function drawNeonSquare() {
  push()

  colorMode(HSB, 360, 100, 100, 100)
  rectMode(CENTER)

  noFill()
  stroke(207, 7, 999)
  strokeWeight(20)

  background(230, 50, 15)

  drawingContext.shadowBlur = 50
  drawingContext.shadowColor = color(207, 7, 99)

  rect(width / 2, height / 2, 200, 300, 30)
  rect(width / 2, height / 2, 200, 300, 30)
  rect(width / 2, height / 2, 200, 300, 30)

  pop()
}



function drawLaser() {

}

class Emitter {
  constructor(x, y, gravity) {
    this.origin = createVector(x, y)
    this.particles = []
  }

  addParticle(particle) {
    this.particles.push(particle)
  }


  applyForce(force) {
    this.particles.forEach(p => p.applyForce(force))
  }
  update() {
    this.particles.forEach(p => p.update())
  }

  draw() {
    this.particles.forEach(p => {
      p.draw()

      if (p.isDead) {
        this.particles.push(new Particle(this.origin.x, this.origin.y))
      }
    })

    this.particles = this.particles.filter(p => !p.isDead)
  }
}

class Particle {
  constructor(x, y) {
    console.log(x, y)
    this.position = createVector(x, y);
    this.acceleration = createVector();
    this.velocity = createVector(random(-15, 15), random(-15, -5));
    this.lifespan = 100;
  }

  applyForce(force) {
    this.acceleration.add(force);
  }


  // TODO: use events and collections to apply behaviour - gravity system.update?
  // todo: where to use update?
  // - camera controller - on mouse move delgate - then update when mouse moved - dont need to check if mouse moved on every frame!
  // - unit system - responsible for unit entities - e.g. moveToPostion() - knows positions and actions they migth take, but not what they look like, has it moved, has it attacked (as delgates)
  // - unit visuals controller - e.g onUnitMoved() - delgate assigned to event - called when event happens
  update() {
    const dt = deltaTime / 1000 // Delta time in seconds

    // Apply acceleration to velocity (scaled by deltaTime)
    const accelDelta = p5.Vector.mult(this.acceleration, dt * 60)
    this.velocity.add(accelDelta)

    // Apply velocity to position (scaled by deltaTime)
    const velocityDelta = p5.Vector.mult(this.velocity, dt * 60)
    this.position.add(velocityDelta)

    this.acceleration.mult(0)
    this.lifespan -= dt * 60 // Decrease at rate of 60 per second
  }

  draw() {
    const alpha = map(this.lifespan, 0, 100, 0, 255)
    stroke(0, alpha);
    fill(175, this.lifespan);

    circle(this.position.x, this.position.y, 8);
  }

  get isDead() {
    return this.lifespan < 0;
  }
}

class ParticleLine {
  constructor(position, velocity, opacity, lifetime, length, colour, rotationSpeed = 0) {
    this.position = position
    this.velocity = velocity
    this.initialOpacity = this.opacity = opacity
    this.initialLifetime = this.lifetime = lifetime
    this.length = length
    this.colour = colour || color(255, 255, 255)
    this.orientation = velocity.heading() // Initial orientation matches velocity direction
    this.rotationSpeed = rotationSpeed // Radians per second to rotate
    this.dragPerSecond = 0.02 // Velocity decay per second (2% per second)
  }

  update() {
    // Delta time in seconds (p5.js deltaTime is in milliseconds)
    const dt = deltaTime / 1000

    // Update position based on velocity and delta time
    const velocityDelta = p5.Vector.mult(this.velocity, dt * 60) // Scale by 60 for similar feel to 60fps
    this.position.add(velocityDelta)

    // Apply drag based on delta time
    const dragFactor = 1 - (this.dragPerSecond * dt * 60)
    this.velocity.mult(dragFactor)

    // Rotate based on delta time
    this.orientation += this.rotationSpeed * dt * 60

    // Decrease lifetime based on delta time
    this.lifetime -= dt * 60 // Decrease at rate of 60 per second (assuming 60fps baseline)

    // Fade opacity as lifetime decreases
    const lifetimeRatio = this.lifetime / this.initialLifetime
    this.opacity = lerp(0, this.initialOpacity, lifetimeRatio)
  }

  draw() {
    push()

    // Move to particle position and rotate
    translate(this.position.x, this.position.y)
    rotate(this.orientation)

    // Draw line from center with glow effect
    strokeWeight(2)
    const alpha = this.opacity
    if (alpha > 0) {
      // Set alpha for the stroke
      const c = color(red(this.colour), green(this.colour), blue(this.colour), alpha)

      // Add glow/shadow blur effect
      drawingContext.shadowBlur = 15
      drawingContext.shadowColor = c

      stroke(c)
      line(-this.length / 2, 0, this.length / 2, 0)

      // Draw a second time for more intensity
      line(-this.length / 2, 0, this.length / 2, 0)

      // Reset shadow
      drawingContext.shadowBlur = 0
    }

    pop()
  }

  get isDead() {
    return this.lifetime <= 0
  }
}

class ClickParticles {
  constructor(position, lifetime = 60, maxVelocity = 15, particleCount = null, maxOffset = 0) {
    this.particles = []
    this.lifetime = lifetime

    // If particleCount not provided, base it on the effect size
    const count = particleCount || int(random(15, 30))

    for (let i = 0; i < count; i++) {
      const angle = random(TWO_PI) // Random direction
      const speed = random(maxVelocity * 0.3, maxVelocity) // Varying speeds
      const velocity = createVector(cos(angle) * speed, sin(angle) * speed)

      // Add random offset from origin
      const offsetAngle = random(TWO_PI)
      const offsetDistance = random(maxOffset)
      const offsetX = cos(offsetAngle) * offsetDistance
      const offsetY = sin(offsetAngle) * offsetDistance
      const startPosition = createVector(position.x + offsetX, position.y + offsetY)

      // Use lifetime to control individual particle lifetimes (with some variation)
      const particleLifetime = random(lifetime * 0.5, lifetime)

      // Color variations - neon green-ish colors
      const hue = random(100, 140) // Green range
      const sat = random(80, 100)
      const bright = random(80, 100)
      colorMode(HSB, 360, 100, 100, 255)
      const particleColor = color(hue, sat, bright, 255)

      this.particles.push(new ParticleLine(
        startPosition,
        velocity,
        random(150, 255), // opacity
        particleLifetime,
        random(10, 25), // length
        particleColor,
        random(-0.1, 0.1) // rotation speed
      ))
    }
  }

  update() {
    this.particles.forEach(p => p.update())
    this.particles = this.particles.filter(p => !p.isDead)
  }

  draw() {
    this.particles.forEach(p => p.draw())
  }

  get isDead() {
    return this.particles.length === 0
  }
}


</script>