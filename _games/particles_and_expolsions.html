---
layout: p5
title: Particles and explosions
description: |
  <div>experimenting with different particle and explosion effects.</div>
---


<template>
  TODO:
  * [ ] efffects from lazers shooting things
  * [ ] effects from things being shot
  * [ ] lasers
  * [ ] Neon lines
  * [ ] propelled rockets
  * [ ] electic bolts
  * [ ] ships exploding and flying apart
  * [ ] ships accelarating
  * [ ] the two pronged projectile that kind of ladders along, _-  -> -_  -> _- 
  * [ ] shields
  * [ ] shields getting hit
</template>

<script defer>

let gravity
let emitter
let clickExplosions = []
let enemyShip

function setup() {
  createCanvas(windowWidth, windowHeight)

  describe('Particles and explosions.')

  gravity = createVector(0, 0.5);
  emitter = new Emitter(width / 2, 50)
  emitter.addParticle(new Particle(width / 2, 50))

  // Create enemy ship
  enemyShip = new EnemyShip(width / 2, height / 2, 40)

}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight)
}

function draw() {

  drawNeonSquare()

  emitter.update()
  emitter.draw()
  emitter.applyForce(gravity)

  // Update and draw enemy ship
  if (enemyShip && !enemyShip.isDead) {
    enemyShip.update()
    enemyShip.draw()
  }

  // Update and draw click explosions
  clickExplosions.forEach(explosion => {
    explosion.update()
    explosion.draw()
  })

  // Remove dead explosions
  clickExplosions = clickExplosions.filter(e => !e.isDead)

  // Display FPS
  push()
  fill(255)
  noStroke()
  textSize(16)
  textAlign(LEFT, TOP)
  text(`FPS: ${frameRate().toFixed(0)} | Particles: ${clickExplosions.reduce((sum, e) => sum + e.particles.length, 0)}`, 10, 10)
  pop()
}

function mousePressed() {
  // Check if clicking on enemy ship
  if (enemyShip && !enemyShip.isDead && enemyShip.isPointInside(mouseX, mouseY)) {
    enemyShip.takeDamage(20)
    return
  }

  // Create explosion at click position
  // Parameters: (position, lifetime, maxVelocity, particleCount, maxOffset)
  // - lifetime: how long particles live (larger = spread further)
  // - maxVelocity: initial speed (larger = spread faster/further)
  // - particleCount: number of particles (null = random 15-30)
  // - maxOffset: initial spread radius from click point

  // Examples:
  // Small, fast burst:
  // clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 30, 20, null, 0))

  // Large, slow expansion:
  // clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 120, 8, null, 0))

  // Tight cluster with offset spread:
  // clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 60, 10, null, 20))

  // Large burst with initial spread:
  // clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 80, 15, 40, 30))

  // Default medium effect with slight offset:
  clickExplosions.push(new ClickParticles(createVector(mouseX, mouseY), 60, 15, null, 10))
}

function drawNeonSquare() {
  push()

  colorMode(HSB, 360, 100, 100, 100)
  rectMode(CENTER)

  noFill()
  stroke(207, 7, 999)
  strokeWeight(20)

  background(230, 50, 15)

  drawingContext.shadowBlur = 50
  drawingContext.shadowColor = color(207, 7, 99)

  rect(width / 2, height / 2, 200, 300, 30)
  rect(width / 2, height / 2, 200, 300, 30)
  rect(width / 2, height / 2, 200, 300, 30)

  pop()
}



function drawLaser() {

}

class Emitter {
  constructor(x, y, gravity) {
    this.origin = createVector(x, y)
    this.particles = []
  }

  addParticle(particle) {
    this.particles.push(particle)
  }


  applyForce(force) {
    this.particles.forEach(p => p.applyForce(force))
  }
  update() {
    this.particles.forEach(p => p.update())
  }

  draw() {
    this.particles.forEach(p => {
      p.draw()

      if (p.isDead) {
        this.particles.push(new Particle(this.origin.x, this.origin.y))
      }
    })

    this.particles = this.particles.filter(p => !p.isDead)
  }
}

class Particle {
  constructor(x, y) {
    console.log(x, y)
    this.position = createVector(x, y);
    this.acceleration = createVector();
    this.velocity = createVector(random(-15, 15), random(-15, -5));
    this.lifespan = 100;
  }

  applyForce(force) {
    this.acceleration.add(force);
  }


  // TODO: use events and collections to apply behaviour - gravity system.update?
  // todo: where to use update?
  // - camera controller - on mouse move delgate - then update when mouse moved - dont need to check if mouse moved on every frame!
  // - unit system - responsible for unit entities - e.g. moveToPostion() - knows positions and actions they migth take, but not what they look like, has it moved, has it attacked (as delgates)
  // - unit visuals controller - e.g onUnitMoved() - delgate assigned to event - called when event happens
  update() {
    const dt = deltaTime / 1000 // Delta time in seconds

    // Apply acceleration to velocity (scaled by deltaTime)
    const accelDelta = p5.Vector.mult(this.acceleration, dt * 60)
    this.velocity.add(accelDelta)

    // Apply velocity to position (scaled by deltaTime)
    const velocityDelta = p5.Vector.mult(this.velocity, dt * 60)
    this.position.add(velocityDelta)

    this.acceleration.mult(0)
    this.lifespan -= dt * 60 // Decrease at rate of 60 per second
  }

  draw() {
    const alpha = map(this.lifespan, 0, 100, 0, 255)
    stroke(0, alpha);
    fill(175, this.lifespan);

    circle(this.position.x, this.position.y, 8);
  }

  get isDead() {
    return this.lifespan < 0;
  }
}

class ParticleLine {
  constructor(position, velocity, opacity, lifetime, length, colour, rotationSpeed = 0) {
    this.position = position
    this.velocity = velocity
    this.initialOpacity = this.opacity = opacity
    this.initialLifetime = this.lifetime = lifetime
    this.length = length
    this.colour = colour || color(255, 255, 255)
    this.orientation = velocity.heading() // Initial orientation matches velocity direction
    this.rotationSpeed = rotationSpeed // Radians per second to rotate
    this.dragPerSecond = 0.02 // Velocity decay per second (2% per second)
  }

  update() {
    // Delta time in seconds (p5.js deltaTime is in milliseconds)
    const dt = deltaTime / 1000

    // Update position based on velocity and delta time
    const velocityDelta = p5.Vector.mult(this.velocity, dt * 60) // Scale by 60 for similar feel to 60fps
    this.position.add(velocityDelta)

    // Apply drag based on delta time
    const dragFactor = 1 - (this.dragPerSecond * dt * 60)
    this.velocity.mult(dragFactor)

    // Rotate based on delta time
    this.orientation += this.rotationSpeed * dt * 60

    // Decrease lifetime based on delta time
    this.lifetime -= dt * 60 // Decrease at rate of 60 per second (assuming 60fps baseline)

    // Fade opacity as lifetime decreases
    const lifetimeRatio = this.lifetime / this.initialLifetime
    this.opacity = lerp(0, this.initialOpacity, lifetimeRatio)
  }

  draw() {
    push()

    // Move to particle position and rotate
    translate(this.position.x, this.position.y)
    rotate(this.orientation)

    // Draw line from center with glow effect
    strokeWeight(2)
    const alpha = this.opacity
    if (alpha > 0) {
      // Set alpha for the stroke
      const c = color(red(this.colour), green(this.colour), blue(this.colour), alpha)

      // Add glow/shadow blur effect
      drawingContext.shadowBlur = 15
      drawingContext.shadowColor = c

      stroke(c)
      line(-this.length / 2, 0, this.length / 2, 0)

      // Draw a second time for more intensity
      line(-this.length / 2, 0, this.length / 2, 0)

      // Reset shadow
      drawingContext.shadowBlur = 0
    }

    pop()
  }

  get isDead() {
    return this.lifetime <= 0
  }
}

class ClickParticles {
  constructor(position, lifetime = 60, maxVelocity = 15, particleCount = null, maxOffset = 0, hueRange = null) {
    this.particles = []
    this.lifetime = lifetime

    // If particleCount not provided, base it on the effect size
    const count = particleCount || int(random(15, 30))

    for (let i = 0; i < count; i++) {
      const angle = random(TWO_PI) // Random direction
      const speed = random(maxVelocity * 0.3, maxVelocity) // Varying speeds
      const velocity = createVector(cos(angle) * speed, sin(angle) * speed)

      // Add random offset from origin
      const offsetAngle = random(TWO_PI)
      const offsetDistance = random(maxOffset)
      const offsetX = cos(offsetAngle) * offsetDistance
      const offsetY = sin(offsetAngle) * offsetDistance
      const startPosition = createVector(position.x + offsetX, position.y + offsetY)

      // Use lifetime to control individual particle lifetimes (with some variation)
      const particleLifetime = random(lifetime * 0.5, lifetime)

      // Color variations
      let hue, sat, bright
      if (hueRange) {
        // Use custom hue range with high saturation/brightness (for ship explosions)
        hue = random(hueRange[0], hueRange[1])
        sat = random(85, 95)
        bright = random(85, 95)
      } else {
        // Original weapon/click colors - neon green-ish colors
        hue = random(100, 140) // Green range
        sat = random(80, 100)
        bright = random(80, 100)
      }
      colorMode(HSB, 360, 100, 100, 255)
      const particleColor = color(hue, sat, bright, 255)

      this.particles.push(new ParticleLine(
        startPosition,
        velocity,
        random(150, 255), // opacity
        particleLifetime,
        random(10, 25), // length
        particleColor,
        random(-0.1, 0.1) // rotation speed
      ))
    }
  }

  update() {
    this.particles.forEach(p => p.update())
    this.particles = this.particles.filter(p => !p.isDead)
  }

  draw() {
    this.particles.forEach(p => p.draw())
  }

  get isDead() {
    return this.particles.length === 0
  }
}

class EnemyShip {
  constructor(x, y, size) {
    this.position = createVector(x, y)
    this.size = size
    this.maxHealth = 100
    this.health = this.maxHealth
    this.isDead = false

    // Ship color - green with subtle hue variations for particles
    this.hueRange = [110, 130] // Subtle green variations for explosion
    colorMode(HSB, 360, 100, 100, 255)
    this.color = color(120, 90, 90, 255)
  }

  update() {
    // Could add ship movement/behavior here
  }

  draw() {
    push()

    // Set color mode for drawing
    colorMode(HSB, 360, 100, 100, 255)

    // Add glow effect
    drawingContext.shadowBlur = 20
    drawingContext.shadowColor = this.color

    // Draw triangle (pointing up)
    translate(this.position.x, this.position.y)

    // Health-based color intensity
    const healthRatio = this.health / this.maxHealth
    const brightness = lerp(30, 90, healthRatio)
    const shipColor = color(120, 90, brightness, 255) // Green hue

    fill(shipColor)
    stroke(shipColor)
    strokeWeight(2)

    // Draw triangle
    triangle(
      0, -this.size / 2,           // Top point
      -this.size / 2, this.size / 2, // Bottom left
      this.size / 2, this.size / 2   // Bottom right
    )

    // Draw health bar
    const barWidth = this.size
    const barHeight = 5
    const barY = this.size / 2 + 15

    // Background bar
    fill(0, 0, 30)
    noStroke()
    rect(-barWidth / 2, barY, barWidth, barHeight)

    // Health bar
    fill(120, 90, 90) // Green hue
    rect(-barWidth / 2, barY, barWidth * healthRatio, barHeight)

    // Reset shadow
    drawingContext.shadowBlur = 0

    pop()
  }

  isPointInside(x, y) {
    // Simple bounding box check for triangle
    const dist = p5.Vector.dist(createVector(x, y), this.position)
    return dist < this.size / 2
  }

  takeDamage(damage) {
    this.health -= damage

    // Emit weapon hit particles - use default weapon colors (NOT ship colors)
    clickExplosions.push(
      new ClickParticles(
        createVector(this.position.x, this.position.y),
        30,           // lifetime
        10,           // maxVelocity
        15,           // particleCount
        this.size / 3  // maxOffset
        // No hueRange - use default weapon colors
      )
    )

    // Check if destroyed
    if (this.health <= 0) {
      this.explode()
      this.isDead = true
    }
  }

  explode() {
    // Create large explosion with ship colors
    clickExplosions.push(
      new ClickParticles(
        createVector(this.position.x, this.position.y),
        80,           // lifetime
        20,           // maxVelocity
        50,           // particleCount
        this.size / 2, // maxOffset
        this.hueRange // color range matching ship
      )
    )
  }
}


</script>